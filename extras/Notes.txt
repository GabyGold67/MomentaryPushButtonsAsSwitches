_ May the begin() method be reformatted as a class method template for each class in the library?

_ May the mpbPollCallback reformatted as a class method template for each class in the library?

_ The Time Latched class must include the possibility of leaving the near end warning turned on as a pilot light

_ TmLtchMPBttn must add method to set a new active time

_ TmVdblMPBttn must add method to set a new voiding time

_ All classes and methods related to times must check a valid range input

_ Double check consecuences of wrnngPrctg = 0!!

Pilot light electrical devices for switch wall plates in residential and commercial locations. These illuminated switches are useful in situations where you want to be alerted that a device or load is on. You'll find pilot lighted rocker switches, Despard switches, toggle switches, single pole and 3 way switches. (Not made in 4-way.) Note that pilot switches are lighted when ON. 15 amp and 20 amp versions available in red, clear, and white. 


The switches to simulate are:  

Classes implemented:
DbncdMPBttn: The MPB debounced, debounce time configurable from 20 milisecs up, the ON signal is true from the programmed debounce time setted up to the MPB release.  

DbncdDlydMPBttn: Identical to the DbncdMPBttn, but an adittional parameter is included for a delay adition from the debounce time and before the ON signal is raised. If the MPB is released before the delay time exhaustion the ON signal will never be rised.  

LtchMPBttn: Similar to the DbncdDlydMPBttn but after a validated press the ON signal is kept raised until a second validated press is received.



Class Candidate 01
class SnglSrvcMPBttn: public DbncdDlydMPBttn{
protected:
    bool _released{true};
    bool _servicePend{false};

public:
    SnglSrvcMPBttn(uint8_t mpbttnPin, bool pulledUp = true, bool typeNO = true, unsigned long int dbncTimeOrigSett = 0, unsigned long int strtDelay = 0);
    bool getSrvcPend(); 
    bool notifySrvd ();
    bool updIsOn();

};

Class Candidate 02
class AutoRptCntlMPBttn: public DbncdMPBttn{
private:
    const unsigned long int _minRptRate = 250;
    bool _autoRptOn;
    bool _released{true};
    bool _rearmed {false};
    bool _servicePend{false};
    unsigned long int _rptRate;

public:
    AutoRptCntlMPBttn(uint8_t mpbttnPin, bool pulledUp, bool typeNO, unsigned long int dbncTime = 0, unsigned long int rptRate = 0, bool autoRptOn = true);
    bool setAutoRptRate(unsigned long int newRate);
    bool getSrvcPend(); 
    bool notifySrvd ();
    bool updValidPress();

};


SnglSrvcMPBttn::SnglSrvcMPBttn(uint8_t mpbttnPin, bool pulledUp, bool typeNO, unsigned long int dbncTimeOrigSett, unsigned long int strtDelay)
:DbncdDlydMPBttn(mpbttnPin, pulledUp, typeNO, dbncTimeOrigSett, strtDelay)
{
}

bool SnglSrvcMPBttn::getSrvcPend(){
    
    return _servicePend;
}

bool SnglSrvcMPBttn::notifySrvd(){
    bool result {false};

    if (_servicePend){
        _servicePend = false;
        _wasPressed = true;
        result = true;
    }

    return result;
}

bool SnglSrvcMPBttn::updIsOn(){
    bool result {false};
    
    if (!_servicePend){
        if (DbncdMPBttn::updIsOn()){
            if (_released == true){
                _servicePend = true;
                _released = false;
                result = true;
            }
        }
        else{
            _released = true;
        }
    }
    else{
        result = true;
    }

    return result;
}

AutoRptCntlMPBttn::AutoRptCntlMPBttn(uint8_t mpbttnPin, bool pulledUp, bool typeNO, unsigned long int dbncTime, unsigned long int rptRate, bool autoRptOn)
:DbncdMPBttn(mpbttnPin, pulledUp, typeNO, dbncTime), _autoRptOn {autoRptOn}
{
    if (rptRate <_minRptRate)
        _rptRate = _minRptRate;
    else
        _rptRate = rptRate;    
}

bool AutoRptCntlMPBttn::setAutoRptRate(unsigned long int newRptRate){
    bool result {false};

    if (newRptRate >= _minRptRate){
        _rptRate = newRptRate;
        result = true;
    }

    return result;
}
bool AutoRptCntlMPBttn::notifySrvd(){
    bool result {false};

    if (_servicePend){
        _servicePend = false;
        if(_autoRptOn){
            _rearmed = true;
            _dbncTimerStrt = millis();
            _wasPressed = true;
        }
        result = true;
    }

    return result;
}

bool AutoRptCntlMPBttn::updValidPress()
{
    bool result {false};
    
    updIsPressed();

    int pinState {digitalRead(_mpbttnPin)};
    bool nowPushed {_isPressed};    //Button is pushed == true
    if (!_servicePend){
        //There's no Service pending of being treated
        if (nowPushed){
            if (_autoRptOn || (!_autoRptOn && _rearmed) ){
                if(_wasPressed){
                    //It was already being pushed, timer is already running
                    if ((millis() - _dbncTimerStrt) >= _dbncTimeOrigSett){
                        _servicePend = true;
                        _rearmed = false;
                    }
                }
                else{
                    //It wasn't already pushed, timer must be started and status changed
                    _dbncTimerStrt = millis();
                    _wasPressed = true;
                }
            }
        }
        else{
            _wasPressed = false;
            if (!_autoRptOn)
                _rearmed = true;
        }
        result = true;
    }
    else{
        //Could not be treated as a Service is pending of treatment        
    }

    return result;
}

X For the latched subclasses the _validPressPending must be provided by different meanings, the rest would be the same...
X A new subclass should be included, a superclass for XtrnUnltchMPBttn that supports the use of a method for unlatching the switch, so that it can be unlatched by sofware
 meanings such as a message from BT or a mail.: solved trough the LtchMPBttn::setUnlatchPend() method that can be invoked from any source

